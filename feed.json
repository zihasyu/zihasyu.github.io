{
    "version": "https://jsonfeed.org/version/1",
    "title": "carzo",
    "subtitle": "Zihasyu's Personal Site",
    "icon": "http://example.com/images/favicon.ico",
    "description": "Hope friends and I can get the happiness we deserve",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/22/hello-world/",
            "url": "http://example.com/2024/07/22/hello-world/",
            "title": "Hello World",
            "date_published": "2024-07-22T13:54:25.496Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/07/04/Summary%20of%20Chunking/",
            "url": "http://example.com/2024/07/04/Summary%20of%20Chunking/",
            "title": "Chunking summary",
            "date_published": "2024-07-04T11:48:04.000Z",
            "content_html": "<h2 id=\"chunking-flow\"><a class=\"anchor\" href=\"#chunking-flow\">#</a> Chunking flow</h2>\n<h3 id=\"flow-chart\"><a class=\"anchor\" href=\"#flow-chart\">#</a> Flow chart</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407251358457.png\" alt=\"image.png\" /></p>\n<h3 id=\"why-only-read-part\"><a class=\"anchor\" href=\"#why-only-read-part\">#</a> Why only Read part\\</h3>\n<p>we unuslly read 128MiB a time from the Tar to Chunking. this will prevent too much memory from being consumed.<br />\nwhen the ReadFileBuffer is about to reach the end, we need to seekg the next beginning of the buffer.</p>\n<h3 id=\"code-sample\"><a class=\"anchor\" href=\"#code-sample\">#</a> Code sample</h3>\n<pre><code class=\"language-c++\">void Chunker::Chunking()\n&#123;\n    bool end = false;\n    uint32_t totalOffset = 0;\n    while (!end)\n    &#123;\n        memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n        inputFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n        end = inputFile.eof();\n        size_t len = inputFile.gcount();\n        if (len == 0)\n        &#123;\n            break;\n        &#125;\n        localOffset = 0;\n        while (((len - localOffset) &gt;= MAXCHUNKSIZE) || (end &amp;&amp; (localOffset &lt; len)))\n        &#123;\n            Chunk_t chunk;\n            uint32_t cp = 0;\n            cp = CutPoint(readFileBuffer + localOffset, len - localOffset);\n            chunk.chunkPtr = (uint8_t *)malloc(cp);\n            memcpy(chunk.chunkPtr, readFileBuffer + localOffset, cp);\n            chunk.chunkSize = cp;\n            localOffset += cp;\n        &#125;\n        totalOffset += localOffset;\n        inputFile.seekg(totalOffset, ios_base::beg);\n    &#125;\n    return;\n&#125;\n</code></pre>\n<h2 id=\"chunking-methods\"><a class=\"anchor\" href=\"#chunking-methods\">#</a> Chunking methods</h2>\n<p>the different  chunking methods are reflected in the way cp is obtained.</p>\n<pre><code class=\"language-C++\">uint32_t cp = Chunking(); \n</code></pre>\n<h3 id=\"fixed-size\"><a class=\"anchor\" href=\"#fixed-size\">#</a> Fixed-size</h3>\n<p>As a tradeoff between Deduplication and throughput, chunking methods typically use 8KiB as the desired average size.</p>\n<pre><code class=\"language-C++\">uint32_t Chunker::FixedSize()&#123;\n\t\treturn FixedChunkSize;\n&#125;\n</code></pre>\n<p>But the fixed-size chunking will encounter a very serious boundary migration problem, which will allow the reactivity to drop.</p>\n<h3 id=\"cdc\"><a class=\"anchor\" href=\"#cdc\">#</a> CDC</h3>\n<p>When the sliding hash in the window is equal to 0 with the mask that operation set in advance, it is used as a breakpoint.This is called content-defined chunking.</p>\n<pre><code class=\"language-c++\">uint32_t Chunker::CutPointCDC(const uint8_t *src, const uint32_t len)\n&#123;\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i &lt; len; i++)\n    &#123;\n        fp = fp - Rabin[src[i-windowSize]] + Rabin[src[i]];\n        if (!(fp &amp; MASK_GEAR))\n        &#123;\n            return (i + 1);\n        &#125;\n    &#125;\n    return i;\n&#125;;\n</code></pre>\n<p>The expected block size is related to the significant bit 1 of the mask. For example, if I want the block size to be 8KiB on average, then I need 13 1's in the mask.</p>\n<h3 id=\"gear\"><a class=\"anchor\" href=\"#gear\">#</a> Gear</h3>\n<p>Gear Hash reduces the computational overhead of the rolling hash by fixing the significant bit 1 of the mask to be the least significant bit, so that gear can obtain the rolling hash value by bit operation.</p>\n<pre><code class=\"language-c++\">uint32_t Chunker::CutPointGear(const uint8_t *src, const uint32_t len)\n&#123;\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i &lt; len; i++)\n    &#123;\n        fp = (fp &gt;&gt; 1) + GEAR[src[i]];\n        if (!(fp &amp; MASK_GEAR))\n        &#123;\n            return (i + 1);\n        &#125;\n    &#125;\n    return i;\n&#125;;\n</code></pre>\n<h3 id=\"fastcdc\"><a class=\"anchor\" href=\"#fastcdc\">#</a> FastCDC</h3>\n<p>FastCDC solves two problems, one is to further improve throughput, and the other is to standardize block sizes in the 4KiB-16KiB range. It skips the first 4KiB without having to compute the hash, and its mask is also standardized to be bitwise, so that when it reaches 16KiB, it immediately gets the breakpoint, whether it meets the breakpoint condition or not. In addition, to achieve an average size of 8KiB, he uses different masks to generate breakpoints in 4K-8K and 8K-16K.</p>\n<pre><code class=\"language-c++\">uint32_t Chunker::CutPointFastCDC(const uint8_t *src, const uint32_t len)\n&#123;\n    uint32_t n;\n    uint32_t fp = 0;\n    uint32_t i;\n    i = min(len, static_cast&lt;uint32_t&gt;(minChunkSize));\n    n = min(normalSize, len);\n    for (; i &lt; n; i++)\n    &#123;\n        fp = (fp &gt;&gt; 1) + GEAR[src[i]];\n        if (!(fp &amp; maskS))\n        &#123;\n            return (i + 1);\n        &#125;\n    &#125;\n\n    n = min(static_cast&lt;uint32_t&gt;(maxChunkSize), len);\n    for (; i &lt; n; i++)\n    &#123;\n        fp = (fp &gt;&gt; 1) + GEAR[src[i]];\n        if (!(fp &amp; maskL))\n        &#123;\n            return (i + 1);\n        &#125;\n    &#125;\n    return i;\n&#125;;\n</code></pre>\n<h3 id=\"mtar\"><a class=\"anchor\" href=\"#mtar\">#</a> mTar</h3>\n<p>mTar argues that the metadata head of the periodic appearance of tar reduces the Deduplication rate</p>\n<pre><code class=\"language-c++\">void MTar()&#123;\n\ttranslate the Tar files to mTar files;\n&#125;;\n\nFastCDC();\n\n</code></pre>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>The chunking method is a part of the compression system that determines the theoretical upper bound. If the obtained chunk contains extremely high boundary offset, then the best feature value selection method cannot obtain excellent results.</p>\n",
            "tags": [
                "Compression algorithms",
                "Chunking",
                "Compression",
                "Storage system",
                "Operating system",
                "Computer science"
            ]
        }
    ]
}